use std::{env, fs, io::Write, path::PathBuf};

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_path = out_dir.join("embedded_rules.rs");
    let mut output = fs::File::create(&out_path).unwrap();
    println!("cargo:warning=Generated file in {}", out_path.display());

    // Header
    writeln!(output, "// AUTO-GENERATED by build.rs - DO NOT EDIT").unwrap();
    writeln!(output, "use std::collections::HashMap;").unwrap();
    writeln!(output, "use regex::Regex;").unwrap();
    writeln!(output, "use lazy_static::lazy_static;").unwrap();
    writeln!(output).unwrap();

    // Rule structs
    writeln!(
        output,
        r#"#[derive(Debug)]
pub struct EmbeddedRule {{
    pub name: &'static str,
    pub extensions: &'static [&'static str],
    pub uuid: &'static str,
    pub sequences: &'static [(usize, &'static [u8])],
    pub regexes: &'static [(&'static str, &'static Regex)],
    pub strings: &'static [&'static str],
    pub min_entropy: u16,
    pub max_entropy: u16,
}}

lazy_static! {{
    pub static ref EMBEDDED_RULES: HashMap<&'static str, EmbeddedRule> = {{
        let mut m = HashMap::new();
"#
    )
    .unwrap();

    // Process each JSON file.
    for entry in fs::read_dir("src/patterns").unwrap() {
        let path = entry.unwrap().path();
        if path.extension().unwrap_or_default() == "json" {
            let json = fs::read_to_string(&path).unwrap();
            let rule: serde_json::Value = serde_json::from_str(&json).unwrap();

            // Extract the relevant fields.
            let name = rule["td"]["name"].as_str().unwrap();
            let extensions = rule["td"]["extensions"].as_array().unwrap();
            let uuid = rule["td"]["uuid"].as_str().unwrap();
            let sequences = rule["pd"]["sequences"].as_array().unwrap();
            let strings = rule["pd"]["strings"].as_array().unwrap();
            let min_entropy = rule["pd"]["min_entropy"].as_u64().unwrap() as u16;
            let max_entropy = rule["pd"]["max_entropy"].as_u64().unwrap() as u16;
            let regexes = rule["pd"]["regex"].as_array().unwrap();

            // Write rule to the output file.
            writeln!(
                output,
                r#"        m.insert("{name}", EmbeddedRule {{
            name: "{name}",
            extensions: &[{}],
            uuid: "{uuid}",
            sequences: &[{}],
            regexes: &[{}],
            strings: &[{}],
            min_entropy: {min_entropy},
            max_entropy: {max_entropy},
        }});
"#,
                extensions
                    .iter()
                    .map(|e| format!("\"{}\"", e.as_str().unwrap()))
                    .collect::<Vec<_>>()
                    .join(", "),
                sequences
                    .iter()
                    .map(|seq| {
                        let offset = seq[0].as_u64().unwrap();
                        let bytes = seq[1].as_array().unwrap();
                        format!(
                            "({offset}, &[{}])",
                            bytes
                                .iter()
                                .map(|b| b.as_u64().unwrap().to_string())
                                .collect::<Vec<_>>()
                                .join(", ")
                        )
                    })
                    .collect::<Vec<_>>()
                    .join(", "),
                regexes
                    .iter()
                    .map(|r| {
                        let pattern = r.as_str().unwrap();
                        format!("(r\"{pattern}\", Regex::new(r\"{pattern}\").unwrap())")
                    })
                    .collect::<Vec<_>>()
                    .join(", "),
                strings
                    .iter()
                    .map(|s| format!("\"{}\"", s.as_str().unwrap()))
                    .collect::<Vec<_>>()
                    .join(", "),
            )
            .unwrap();
        }
    }

    writeln!(output, "        m\n    }};\n}}").unwrap();
}
