use std::{env, fs, io::Write, path::PathBuf};

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_path = out_dir.join("embedded_rules.rs");
    let mut output = fs::File::create(&out_path).unwrap();
    println!("cargo:warning=Generated file in {}", out_path.display());

    // Header
    writeln!(output, "// AUTO-GENERATED by build.rs - DO NOT EDIT").unwrap();
    writeln!(output, "#[allow(dead_code)]").unwrap();
    writeln!(output, "use std::collections::HashMap;").unwrap();
    writeln!(output, "use regex::Regex;").unwrap();
    writeln!(output, "use lazy_static::lazy_static;").unwrap();
    writeln!(output, "use crate::embedded_rule::*;").unwrap();
    writeln!(output).unwrap();

    // Rule structs
    writeln!(
        output,
        r#"lazy_static! {{
    pub static ref EMBEDDED_RULES: HashMap<&'static str, EmbeddedRule> = {{
        let mut m = HashMap::new();
"#
    )
    .unwrap();

    static EMPTY_VEC: Vec<serde_json::Value> = Vec::new();

    // Process each JSON file.
    for entry in fs::read_dir("./patterns").unwrap() {
        let path = entry.unwrap().path();
        if path.extension().unwrap_or_default() == "json" {
            let json = fs::read_to_string(&path).unwrap();
            let rule: serde_json::Value = serde_json::from_str(&json).unwrap();

            // Extract the relevant fields.
            let name = rule["td"]["name"].as_str().unwrap();
            let extensions = rule["td"]
                .get("extensions")
                .and_then(|v| v.as_array())
                .unwrap_or(&EMPTY_VEC);
            let mimes = rule["td"]
                .get("mimetypes")
                .and_then(|v| v.as_array())
                .unwrap_or(&EMPTY_VEC);
            let uuid = rule["td"]["uuid"].as_str().unwrap();
            let sequences = rule["pd"]
                .get("sequences")
                .and_then(|v| v.as_array())
                .unwrap_or(&EMPTY_VEC);
            let strings = rule["pd"]
                .get("strings")
                .and_then(|v| v.as_array())
                .unwrap_or(&EMPTY_VEC);
            let min_entropy = rule["pd"]
                .get("min_entropy")
                .and_then(|v| v.as_u64())
                .unwrap_or(0) as u16;
            let max_entropy = rule["pd"]
                .get("max_entropy")
                .and_then(|v| v.as_u64())
                .unwrap_or(0) as u16;
            let regexes = rule["pd"]
                .get("regex")
                .and_then(|v| v.as_array())
                .unwrap_or(&EMPTY_VEC);

            // Write rule to the output file.
            writeln!(
                output,
                r#"        m.insert("{name}", EmbeddedRule {{
            name: "{name}",
            extensions: &[{}],
            mimes: &[{}],
            uuid: "{uuid}",
            sequences: &[{}],
            regexes: &[{}],
            strings: &[{}],
            min_entropy: {min_entropy},
            max_entropy: {max_entropy},
        }});
"#,
                extensions
                    .iter()
                    .map(|e| format!("\"{}\"", e.as_str().unwrap()))
                    .collect::<Vec<_>>()
                    .join(", "),
                mimes
                    .iter()
                    .map(|m| format!("\"{}\"", m.as_str().unwrap()))
                    .collect::<Vec<_>>()
                    .join(", "),
                sequences
                    .iter()
                    .map(|seq| {
                        let offset = seq[0].as_u64().unwrap();
                        let bytes = seq[1].as_array().unwrap();
                        format!(
                            "({offset}, &[{}])",
                            bytes
                                .iter()
                                .map(|b| b.as_u64().unwrap().to_string())
                                .collect::<Vec<_>>()
                                .join(", ")
                        )
                    })
                    .collect::<Vec<_>>()
                    .join(", "),
                regexes
                    .iter()
                    .map(|r| {
                        let pattern = r.as_str().unwrap();
                        format!("(r\"{pattern}\", Regex::new(r\"{pattern}\").unwrap())")
                    })
                    .collect::<Vec<_>>()
                    .join(", "),
                strings
                    .iter()
                    .map(|s| format!("\"{}\"", s.as_str().unwrap()))
                    .collect::<Vec<_>>()
                    .join(", "),
            )
            .unwrap();
        }
    }

    writeln!(output, "        m\n    }};\n}}").unwrap();
}
